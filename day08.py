def dfs(g, i, visited):
    visited[i] = 1  #i = 노드의 값(A,B,C,D,E)
    #print(visited) #중간의 visited 과정을 보고 싶으면 실행
    print(chr(ord('A')+i), end=' ')#연결된 값을 출력
    #graph=[[]] 이중 리스트 내부의 길이만큼
    for j in range(len(g)):
    #각 문자와 연결이 되어 있음      #방문한 적이 없어야 함
        if g[i][j] == 1 and not visited[j]:
            dfs(g, j, visited)  #방문X 시에만 재귀
                #연결된 문자 j의 값을 다시 노드의 값으로
                #전부 만족을 못하면 다시 이전의 문자로 돌아감(이전 재귀로 돌아감)

# 연결O: 1, 연결X:0
graph = [
    [0, 0, 1, 1, 0],
    [0, 0, 1, 0, 0],
    [1, 1, 0, 1, 1],
    [1, 0, 1, 0, 0],
    [0, 0, 1, 0, 0]
]

visited = [0] * len(graph)
dfs(graph, 0, visited)
#graph=[[],[],[]] , visited=[]
# i:0스타트 값을 A로 줌

""""
visited변화
[0,0,0,0,0]
[1,0,0,0,0]A
[1,0,1,0,0]C
[1,1,1,0,0]B
다시 B의 바깥 C로
[1,1,1,0,0]C -> [1,1,1,0,1]D
다시 D의 바깥 C로
[1,1,1,0,1]C -> [1,1,1,1,1]E
"""

"""
문자의 연결
A->C    (A-C 연결)
C->B     (C-B 연결)
B는 조건을 만족하는 연결이 없음(이미 갔던 장소) -> 다시 C로 이동
C->D     (C-D 연결)
D는 조건을 만족하는 연결이 없음(이미 갔던 장소) -> 다시 C로 이동
C->E     (C-E 연결)

A->C->B~>C->D~>C->E

A - C - B
| / |
D - E
"""